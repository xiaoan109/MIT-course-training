//
// Generated by Bluespec Compiler, version 2023.01 (build 52adafa5)
//
// On Wed Sep 25 04:41:13 UTC 2024
//
//
// Ports:
// Name                         I/O  size props
// RDY_putSampleInput             O     1 reg
// getSampleOutput                O    16 reg
// RDY_getSampleOutput            O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// putSampleInput_in              I    16 reg
// EN_putSampleInput              I     1
// EN_getSampleOutput             I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkFIRFilter(CLK,
		   RST_N,

		   putSampleInput_in,
		   EN_putSampleInput,
		   RDY_putSampleInput,

		   EN_getSampleOutput,
		   getSampleOutput,
		   RDY_getSampleOutput);
  input  CLK;
  input  RST_N;

  // action method putSampleInput
  input  [15 : 0] putSampleInput_in;
  input  EN_putSampleInput;
  output RDY_putSampleInput;

  // actionvalue method getSampleOutput
  input  EN_getSampleOutput;
  output [15 : 0] getSampleOutput;
  output RDY_getSampleOutput;

  // signals for module outputs
  wire [15 : 0] getSampleOutput;
  wire RDY_getSampleOutput, RDY_putSampleInput;

  // ports of submodule infifo
  wire [15 : 0] infifo$D_IN, infifo$D_OUT;
  wire infifo$CLR, infifo$DEQ, infifo$EMPTY_N, infifo$ENQ, infifo$FULL_N;

  // ports of submodule outfifo
  wire [15 : 0] outfifo$D_IN, outfifo$D_OUT;
  wire outfifo$CLR, outfifo$DEQ, outfifo$EMPTY_N, outfifo$ENQ, outfifo$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_process,
       CAN_FIRE_getSampleOutput,
       CAN_FIRE_putSampleInput,
       WILL_FIRE_RL_process,
       WILL_FIRE_getSampleOutput,
       WILL_FIRE_putSampleInput;

  // action method putSampleInput
  assign RDY_putSampleInput = infifo$FULL_N ;
  assign CAN_FIRE_putSampleInput = infifo$FULL_N ;
  assign WILL_FIRE_putSampleInput = EN_putSampleInput ;

  // actionvalue method getSampleOutput
  assign getSampleOutput = outfifo$D_OUT ;
  assign RDY_getSampleOutput = outfifo$EMPTY_N ;
  assign CAN_FIRE_getSampleOutput = outfifo$EMPTY_N ;
  assign WILL_FIRE_getSampleOutput = EN_getSampleOutput ;

  // submodule infifo
  FIFO2 #(.width(32'd16), .guarded(1'd1)) infifo(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(infifo$D_IN),
						 .ENQ(infifo$ENQ),
						 .DEQ(infifo$DEQ),
						 .CLR(infifo$CLR),
						 .D_OUT(infifo$D_OUT),
						 .FULL_N(infifo$FULL_N),
						 .EMPTY_N(infifo$EMPTY_N));

  // submodule outfifo
  FIFO2 #(.width(32'd16), .guarded(1'd1)) outfifo(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(outfifo$D_IN),
						  .ENQ(outfifo$ENQ),
						  .DEQ(outfifo$DEQ),
						  .CLR(outfifo$CLR),
						  .D_OUT(outfifo$D_OUT),
						  .FULL_N(outfifo$FULL_N),
						  .EMPTY_N(outfifo$EMPTY_N));

  // rule RL_process
  assign CAN_FIRE_RL_process = infifo$EMPTY_N && outfifo$FULL_N ;
  assign WILL_FIRE_RL_process = CAN_FIRE_RL_process ;

  // submodule infifo
  assign infifo$D_IN = putSampleInput_in ;
  assign infifo$ENQ = EN_putSampleInput ;
  assign infifo$DEQ = CAN_FIRE_RL_process ;
  assign infifo$CLR = 1'b0 ;

  // submodule outfifo
  assign outfifo$D_IN = infifo$D_OUT ;
  assign outfifo$ENQ = CAN_FIRE_RL_process ;
  assign outfifo$DEQ = EN_getSampleOutput ;
  assign outfifo$CLR = 1'b0 ;

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process)
	$display("got sample: %h", $signed(infifo$D_OUT));
  end
  // synopsys translate_on
endmodule  // mkFIRFilter

